-- Final fix for vector database schema for Sentence Transformers (384 dimensions)
-- Run this in your Supabase SQL editor

-- 1. Drop existing embedding columns and recreate with correct dimensions
ALTER TABLE public.global_knowledge_base_entries DROP COLUMN IF EXISTS embedding;
ALTER TABLE public.knowledge_base_entries DROP COLUMN IF EXISTS embedding;

-- 2. Add embedding columns with correct dimensions
ALTER TABLE public.global_knowledge_base_entries ADD COLUMN embedding vector(384);
ALTER TABLE public.knowledge_base_entries ADD COLUMN embedding vector(384);

-- 3. Add comments
COMMENT ON COLUMN public.global_knowledge_base_entries.embedding IS '384-dimensional embedding vector generated by Sentence Transformers all-MiniLM-L6-v2';
COMMENT ON COLUMN public.knowledge_base_entries.embedding IS '384-dimensional embedding vector generated by Sentence Transformers all-MiniLM-L6-v2';

-- 4. Create indexes for vector similarity search
CREATE INDEX IF NOT EXISTS idx_global_kb_embeddings ON public.global_knowledge_base_entries USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
CREATE INDEX IF NOT EXISTS idx_kb_embeddings ON public.knowledge_base_entries USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

-- 5. Drop any existing conflicting functions
DROP FUNCTION IF EXISTS get_smart_kb_context(text, integer, real);
DROP FUNCTION IF EXISTS get_smart_kb_context(text, integer);
DROP FUNCTION IF EXISTS get_smart_kb_context(text);
DROP FUNCTION IF EXISTS generate_embedding(text);

-- 6. Create function to generate embeddings for queries (placeholder)
CREATE OR REPLACE FUNCTION generate_embedding(text_content TEXT)
RETURNS TABLE(embedding vector(384)) AS $$
BEGIN
    -- This function will be called by the application to generate embeddings
    -- The actual embedding generation happens in Python using Sentence Transformers
    -- This is just a placeholder for the database function
    RETURN QUERY SELECT NULL::vector(384);
END;
$$ LANGUAGE plpgsql;

-- 7. Create the main semantic search function with proper column types
CREATE OR REPLACE FUNCTION get_smart_kb_context(
    query_text TEXT,
    max_results INTEGER DEFAULT 5,
    similarity_threshold REAL DEFAULT 0.3
)
RETURNS TABLE(
    entry_id UUID,
    name VARCHAR(255),  -- Match the actual column type in your database
    content TEXT,
    similarity REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        g.entry_id,
        g.name,
        g.content,
        (g.embedding <=> query_embedding.embedding) AS similarity
    FROM
        global_knowledge_base_entries g,
        (SELECT embedding FROM generate_embedding(query_text)) AS query_embedding
    WHERE
        g.embedding IS NOT NULL
        AND (g.embedding <=> query_embedding.embedding) < similarity_threshold
    ORDER BY
        similarity ASC
    LIMIT max_results;
END;
$$ LANGUAGE plpgsql;

-- 8. Create a simpler function that doesn't rely on the placeholder generate_embedding
CREATE OR REPLACE FUNCTION get_smart_kb_context_simple(
    query_text TEXT,
    max_results INTEGER DEFAULT 5,
    similarity_threshold REAL DEFAULT 0.3
)
RETURNS TABLE(
    entry_id UUID,
    name VARCHAR(255),
    content TEXT,
    similarity REAL
) AS $$
BEGIN
    -- This function will be called by the application with pre-computed embeddings
    -- For now, return empty results until embeddings are generated
    RETURN QUERY
    SELECT
        g.entry_id,
        g.name,
        g.content,
        0.0 AS similarity
    FROM
        global_knowledge_base_entries g
    WHERE
        g.embedding IS NOT NULL
    LIMIT 0;  -- Return no results until embeddings are properly set up
END;
$$ LANGUAGE plpgsql;

-- 9. Test the functions
SELECT 'Function created successfully' as status;

-- 10. Show the current table structure
SELECT 
    column_name, 
    data_type, 
    character_maximum_length
FROM information_schema.columns 
WHERE table_name = 'global_knowledge_base_entries' 
AND column_name IN ('entry_id', 'name', 'content', 'embedding')
ORDER BY ordinal_position;
